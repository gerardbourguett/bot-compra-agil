name: CI/CD Pipeline

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Bot image
        uses: docker/build-push-action@v5
        with:
          context: .
          target: bot
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/bot:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push Scraper image
        uses: docker/build-push-action@v5
        with:
          context: .
          target: scraper
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/scraper:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    needs: build-and-push
    runs-on: self-hosted  # <--- Esto ejecuta el c칩digo DIRECTAMENTE en tu servidor
    steps:
      - name: Desplegar en Servidor Local
        run: |  # <--- Usamos 'run' directo, sin SSH Action
          # 1. Login en GHCR (Usamos el token del repo)
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

          # 2. Bajar las im치genes nuevas
          docker pull ghcr.io/${{ github.repository }}/bot:latest
          docker pull ghcr.io/${{ github.repository }}/scraper:latest

          # 3. Preparar directorio
          mkdir -p app
          cd app

          # 4. Actualizar c칩digo
          # Usamos el token para clonar sin contrase침a interactiva
          REPO_URL="https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git"

          if [ -d ".git" ]; then
            git remote set-url origin "$REPO_URL"
            git pull origin main
          else
            git clone "$REPO_URL" .
          fi

          # 5. CREAR ARCHIVO .ENV
          echo "POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}" > .env
          echo "TELEGRAM_TOKEN=${{ secrets.TELEGRAM_TOKEN }}" >> .env
          echo "GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}" >> .env
          # Forzamos a que docker-compose use la imagen del repo, no local
          echo "IMAGE_REPO=${{ github.repository }}" >> .env

          # 6. Limpiar contenedores antiguos (para evitar conflictos de nombres)
          docker rm -f compra_agil_db compra_agil_scraper compra_agil_bot || true

          # 6. Reiniciar servicios
          # Detectamos si usar 'docker compose' (v2) o 'docker-compose' (v1)
          if docker compose version >/dev/null 2>&1; then
              docker compose down || true
              docker compose up -d
          else
              docker-compose down || true
              docker-compose up -d
          fi

          # 7. Limpieza
          docker image prune -f
