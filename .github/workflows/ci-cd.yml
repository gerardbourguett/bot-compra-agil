name: CI/CD Pipeline

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push Bot image
        uses: docker/build-push-action@v5
        with:
          context: .
          target: bot
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/bot:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push Scraper image
        uses: docker/build-push-action@v5
        with:
          context: .
          target: scraper
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/scraper:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    needs: build-and-push
    runs-on: self-hosted # <--- Esto ejecuta el c√≥digo DIRECTAMENTE en tu servidor
    steps:
      - name: Desplegar en Servidor Local
        run: | # <--- Usamos 'run' directo, sin SSH Action
          # 1. Login en GHCR (Usamos el token del repo)
          echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

          # 2. Bajar las im√°genes nuevas
          docker pull ghcr.io/${{ github.repository }}/bot:latest
          docker pull ghcr.io/${{ github.repository }}/scraper:latest

          # 3. Preparar directorio
          mkdir -p app
          cd app

          # 4. Actualizar c√≥digo
          # Usamos el token para clonar sin contrase√±a interactiva
          REPO_URL="https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git"

          if [ -d ".git" ]; then
            git remote set-url origin "$REPO_URL"
            git fetch origin main
            git reset --hard origin/main
          else
            git clone "$REPO_URL" .
          fi

          # 5. CREAR ARCHIVO .ENV
          echo "POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}" > .env
          echo "TELEGRAM_TOKEN=${{ secrets.TELEGRAM_TOKEN }}" >> .env
          echo "GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}" >> .env
          # Forzamos a que docker-compose use la imagen del repo, no local
          echo "IMAGE_REPO=${{ github.repository }}" >> .env

          # 6. Verificar vol√∫menes existentes
          echo "üìä Verificando vol√∫menes antes del despliegue..."
          docker volume ls | grep postgres || echo "No hay volumen de postgres a√∫n"

          # 7. Crear backup autom√°tico de BD (OBLIGATORIO si existe)
          echo "üíæ Creando backup de seguridad..."
          mkdir -p backups
          BACKUP_FILE="backups/backup_$(date +%Y%m%d_%H%M%S).sql"

          # Detectar qu√© comando de docker-compose usar
          if docker compose version >/dev/null 2>&1; then
              DOCKER_COMPOSE="docker compose"
          else
              DOCKER_COMPOSE="docker-compose"
          fi

          # Verificar si la BD existe
          if docker ps --format '{{.Names}}' | grep -q compra_agil_db; then
            echo "‚úì BD detectada, creando backup OBLIGATORIO..."

            # Intentar backup - SI FALLA, DETENER TODO
            if $DOCKER_COMPOSE exec -T postgres pg_dump -U compra_agil_user compra_agil > "$BACKUP_FILE" 2>/dev/null; then
              BACKUP_SIZE=$(du -h "$BACKUP_FILE" | cut -f1)
              echo "‚úÖ Backup creado exitosamente: $BACKUP_FILE ($BACKUP_SIZE)"

              # Verificar que el backup no est√© vac√≠o
              if [ ! -s "$BACKUP_FILE" ]; then
                echo "‚ùå ERROR CR√çTICO: Backup creado pero est√° vac√≠o!"
                exit 1
              fi
            else
              echo "‚ùå ERROR CR√çTICO: No se pudo crear el backup de la base de datos!"
              echo "üõë Deteniendo deploy para prevenir p√©rdida de datos"
              exit 1
            fi
          else
            echo "‚ö†Ô∏è No hay BD existente para backup (normal en primer despliegue)"
          fi

          # Mantener solo los √∫ltimos 10 backups locales
          ls -t backups/backup_*.sql 2>/dev/null | tail -n +11 | xargs -r rm || true
          echo "üì¶ Backups locales: $(ls -1 backups/backup_*.sql 2>/dev/null | wc -l)"

          # 8. Limpiar contenedores antiguos (para evitar conflictos de nombres)
          echo "üßπ Limpiando contenedores antiguos..."
          docker rm -f compra_agil_db compra_agil_scraper compra_agil_bot || true

          # 9. Reiniciar servicios SIN eliminar vol√∫menes
          echo "üîÑ Reiniciando servicios (preservando vol√∫menes)..."
          # ‚ö†Ô∏è CR√çTICO: NO usar -v porque elimina TODOS los datos de PostgreSQL
          # ‚úì Usar solo 'down' para preservar vol√∫menes
          $DOCKER_COMPOSE down || true
          $DOCKER_COMPOSE up -d

          # 9.5. Ejecutar migraciones de base de datos
          echo "üóÑÔ∏è Ejecutando migraciones de base de datos..."
          sleep 15  # Esperar a que PostgreSQL est√© listo
          
          # Ejecutar todas las migraciones en orden
          if [ -d "scripts" ]; then
            for migration_script in scripts/migrate_*.py; do
              if [ -f "$migration_script" ]; then
                echo "  üìã Ejecutando: $migration_script"
                python "$migration_script" || echo "  ‚ö†Ô∏è Migraci√≥n ya ejecutada o error (continuando...)"
              fi
            done
            echo "‚úÖ Migraciones completadas"
          else
            echo "‚ö†Ô∏è No se encontr√≥ directorio scripts/"
          fi

          # 10. Verificar que el volumen sigue existiendo
          echo "‚úì Verificando persistencia de vol√∫menes..."
          docker volume ls | grep postgres && echo "‚úì Volumen de postgres preservado" || echo "‚ùå ERROR: Volumen eliminado!"

          # 11. Esperar a que PostgreSQL est√© listo
          echo "‚è≥ Esperando a que PostgreSQL est√© listo..."
          sleep 10

          # 12. Verificar datos en la base de datos
          echo "üìä Verificando datos en la base de datos..."
          $DOCKER_COMPOSE exec -T postgres psql -U compra_agil_user -d compra_agil -c \
            "SELECT 'Licitaciones: ' || COUNT(*)::text FROM licitaciones UNION ALL SELECT 'Hist√≥rico: ' || COUNT(*)::text FROM historico_licitaciones;" \
            2>/dev/null || echo "‚ö†Ô∏è Tablas a√∫n no existen (se crear√°n autom√°ticamente)"

          # 13. Limpieza de im√°genes (NO vol√∫menes)
          echo "üßπ Limpiando im√°genes antiguas..."
          docker image prune -f
